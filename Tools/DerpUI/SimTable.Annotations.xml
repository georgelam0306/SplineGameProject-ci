<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SimTable.Annotations</name>
    </assembly>
    <members>
        <member name="T:SimTable.IDerivedSimSystem">
            <summary>
            Interface for derived systems that cache computed state from SimWorld.
            Derived systems are invalidated after snapshot restore and rebuilt on demand.
            </summary>
        </member>
        <member name="M:SimTable.IDerivedSimSystem.Invalidate">
            <summary>
            Mark all cached state as dirty. Called after rollback/snapshot restore.
            </summary>
        </member>
        <member name="M:SimTable.IDerivedSimSystem.Rebuild">
            <summary>
            Rebuild cached state from authoritative data if dirty.
            Called every BeginFrame in registered order.
            </summary>
        </member>
        <member name="T:SimTable.SimHandle">
            <summary>
            Type-safe handle to a row in a SimTable with generational validation.
            StableId packs generation (upper 16 bits) and rawId (lower 16 bits).
            Stale handles are detected when generation doesn't match current table generation.
            </summary>
        </member>
        <member name="P:SimTable.SimHandle.Generation">
            <summary>Generation counter at time of handle creation (upper 16 bits).</summary>
        </member>
        <member name="P:SimTable.SimHandle.RawId">
            <summary>Raw ID without generation (lower 16 bits).</summary>
        </member>
        <member name="M:SimTable.SimHandle.#ctor(System.Int32,System.Int32)">
            <summary>
            Reconstruct a handle from a packed stableId (for stored references).
            </summary>
        </member>
        <member name="T:SimTable.EvictionPolicy">
            <summary>
            Cache eviction policy for SimTables when full.
            </summary>
        </member>
        <member name="F:SimTable.EvictionPolicy.None">
            <summary>No eviction - throws exception when full (default).</summary>
        </member>
        <member name="F:SimTable.EvictionPolicy.LRU">
            <summary>Least Recently Used - evicts row with lowest LRUKeyField value.</summary>
        </member>
        <member name="P:SimTable.SimTableAttribute.ChunkSize">
            <summary>
            World units per chunk dimension. When > 0, enables chunked spatial mode
            where multiple grids tile across an infinite world. Each chunk has its own
            GridSize Ã— GridSize cell grid. Set to 0 (default) for single-grid mode.
            </summary>
        </member>
        <member name="P:SimTable.SimTableAttribute.EvictionPolicy">
            <summary>
            Eviction policy when table is full. Default is None (throws exception).
            </summary>
        </member>
        <member name="P:SimTable.SimTableAttribute.LRUKeyField">
            <summary>
            Field name to use as LRU key (must be int type). Required when EvictionPolicy is LRU.
            The row with the lowest value in this field will be evicted when the table is full.
            </summary>
        </member>
        <member name="T:SimTable.SimDataTableAttribute">
            <summary>
            Marks a struct for SimTable code generation without spatial partitioning.
            Use for singleton or data-only tables that don't need spatial queries.
            </summary>
        </member>
        <member name="P:SimTable.SimDataTableAttribute.AutoAllocate">
            <summary>
            When true (default), SimWorld constructor auto-allocates one row with field initializer defaults.
            Reset() also re-allocates after clearing. Set to false to disable auto-allocation.
            </summary>
        </member>
        <member name="T:SimTable.ComputedStateAttribute">
            <summary>
            Marks a field as computed state - stored in the slab but not serialized.
            Computed fields are placed after authoritative fields in the contiguous slab.
            After deserialization, computed fields must be recomputed via RecomputeAll().
            Use with a Setup method marked [Conditional("COMPUTED_STATE_SETUP")] to define computation.
            </summary>
        </member>
        <member name="T:SimTable.IComputedStateBuilder`1">
            <summary>
            Builder interface for defining computed field expressions.
            Used in Setup methods with [Conditional("COMPUTED_STATE_SETUP")].
            The generator parses these expressions at compile time to generate RecomputeAll().
            </summary>
            <typeparam name="T">The row struct type.</typeparam>
        </member>
        <member name="M:SimTable.IComputedStateBuilder`1.Compute``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Defines a computed field expression using row-local fields.
            Use [CachedStat] fields to access data from GameDocDb.
            </summary>
            <typeparam name="TField">The field type.</typeparam>
            <param name="targetField">Selector for the computed field (e.g., r => r.FinalSpeed).</param>
            <param name="computation">Expression to compute the value (e.g., r => r.BaseSpeed * r.Modifier).</param>
            <returns>The builder for chaining.</returns>
        </member>
        <member name="M:SimTable.IComputedStateBuilder`1.Compute``2(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`0,``1,``0}})">
            <summary>
            Defines a computed field expression with cross-table access via SimWorld.
            Use when computation depends on data from other tables.
            </summary>
            <typeparam name="TField">The field type.</typeparam>
            <typeparam name="TWorld">The SimWorld type (inferred).</typeparam>
            <param name="targetField">Selector for the computed field.</param>
            <param name="computation">Expression with world access (e.g., (r, world) => world.BuildingRows.Field(r.Slot) + r.Base).</param>
            <returns>The builder for chaining.</returns>
        </member>
        <member name="T:SimTable.ArrayAttribute">
            <summary>
            Marks a field as a fixed-size array. The generator will expand this into
            individual named fields (e.g., Field0, Field1...) plus array accessors.
            Memory is laid out contiguously per-slot for cache-friendly access.
            </summary>
        </member>
        <member name="T:SimTable.Array2DAttribute">
            <summary>
            Marks a field as a fixed-size 2D array. Memory is laid out contiguously
            in row-major order (rows * cols elements) for blittable snapshotting.
            Generates accessors: Field(slot, row, col), FieldRow(slot, row) -> Span.
            </summary>
        </member>
        <member name="T:SimTable.GenerateFlagsAttribute">
            <summary>
            Marks a [Flags] enum for ergonomic extension method generation.
            Generates Is{Flag}(), Set{Flag}(bool), With{Flag}(), Without{Flag}() methods.
            </summary>
        </member>
        <member name="T:SimTable.MultiTableQueryAttribute">
            <summary>
            Marks an interface as a multi-table query. The generator will find all [SimTable]
            structs with matching field names and types, and generate unified iteration support.
            Interface properties must be ref-returning (e.g., ref int Health { get; }).
            Optionally specify explicit types to include (prevents auto-discovery of other matching types).
            </summary>
        </member>
        <member name="P:SimTable.MultiTableQueryAttribute.IncludedTypes">
            <summary>
            Explicit types to include in the query. If empty, auto-discovers all matching types.
            </summary>
        </member>
        <member name="M:SimTable.MultiTableQueryAttribute.#ctor">
            <summary>
            Auto-discover all [SimTable] types with matching fields.
            </summary>
        </member>
        <member name="M:SimTable.MultiTableQueryAttribute.#ctor(System.Type[])">
            <summary>
            Only include the specified types (no auto-discovery).
            </summary>
        </member>
        <member name="T:SimTable.TableUnionAttribute">
            <summary>
            Marks a struct as a table union over explicitly listed table types.
            Generates unified iteration over the specified tables with type discrimination support.
            </summary>
        </member>
    </members>
</doc>
